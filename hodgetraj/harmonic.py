import numpy as np
import copy
import random
import networkx as nx
from scipy.sparse import linalg, csr_matrix
from scipy.spatial import Delaunay,distance
from .util import tuple_increase, top_n_from, is_in_2sets

def harmonic_projection_matrix_with_w(L1: csr_matrix, number_of_holes: int) -> dict:
    """
    Coputes the harmonic projection matrix for the simplicial complex with the
    given Hodge-1 Laplacian.

    Parameters
    ----------
    L1 : csr_matrix of type float
    number_of_holes : int
    """
    w, v = linalg.eigsh(L1, k=number_of_holes,
                        v0=np.ones(L1.shape[0]), which='SM')
    return {"w":w, "v":v.T}



def truncated_delaunay(position, trunc_quantile=0.75, trunc_times=3):
    """
    delaunay on a layout, then remove edges > trunc_quantile * trunc_times

    Parameters
    ---------
    position: 2D pd.array for the running of delaunay
    trunc_quantile: quantile value for the tunc of the Delaunay output
    trunc_times: distance of trunc_quantile x trunc_times will be removed
    """


    if type(position) == dict:
        position = np.array([position[x] for x in range(max(position.keys()) + 1)])
    tri = Delaunay(position)
    ti = tuple_increase
    tri_edges =[[ti(a,b),ti(a,c),ti(b,c)] for a,b,c in tri.simplices]
    tri_edges = list(set([item for sublist in tri_edges for item in sublist])) # flatten
    edges_distance = [distance.euclidean(tuple(position[a]),tuple(position[b])) for (a,b) in tri_edges]
    threshold = np.quantile(edges_distance, trunc_quantile) * trunc_times
    keep_edges = [tri_edges[i] for i in range(len(tri_edges)) if edges_distance[i] < threshold]
    return keep_edges


def truncated_delaunay_keep_end(position, trunc_quantile=0.75, trunc_times=3, keep_n=10):
    """
    position: 2D pd.array for the running of delaunay
    trunc_quantile: quantile value for the tunc of the Delaunay output
    trunc_times: distance of trunc_quantile x trunc_times will be removed

    Parameters
    ---------
    position: layouts dict or array
    """


    if type(position) == dict:
        position = np.array([position[x] for x in range(max(position.keys()) + 1)])
    tri = Delaunay(position)
    ti = tuple_increase
    tri_edges =[[ti(a,b),ti(a,c),ti(b,c)] for a,b,c in tri.simplices]
    tri_edges = list(set([item for sublist in tri_edges for item in sublist])) # flatten
    edges_distance = [distance.euclidean(tuple(position[a]),tuple(position[b])) for (a,b) in tri_edges]
    keep_n_idx = [] if keep_n <= 0 else  np.argpartition(edges_distance, -keep_n)[-keep_n:]
    threshold = np.quantile(edges_distance, trunc_quantile) * trunc_times
    keep_edges = [tri_edges[i] for i in range(len(tri_edges)) if edges_distance[i] < threshold or i not in keep_n_idx]
    return keep_edges
#endf

def truncate_graph(G, layouts , trunc_quantile=0.75, trunc_times=3):
    """
    truncated the edges due to its long distance on the layouts

    Parameters
    ---------
    G: networkx.Graph
    layouts: layouts
    trunc_quantile:
    trunc_times:

    """
    trunc_quantile=0.75; trunc_times=3
    if type(layouts) == dict:
        layouts_list = np.array([layouts[x] for x in range(max(layouts.keys()) + 1)])
    edges = list(G.edges())

    edges_distance = [distance.euclidean(tuple(layouts_list[a]),tuple(layouts_list[b])) for (a,b) in edges]
    threshold = np.quantile(edges_distance, trunc_quantile) * trunc_times
    keep_edges = [edges[i] for i in range(len(edges)) if edges_distance[i] < threshold]
    nG = nx.create_empty_copy(G)
    nG.add_edges_from(keep_edges)
    return nG
#endf


def untangle_starts_ends(g,
                         group,
                         addedges,
                         layouts,
                         olayouts,
                         all_nodes_in_celltype=False,
                         trunc_quantile_cluster=0.75,
                         trunc_times_cluster=6,
                         trunc_quantile_o=0.75,
                         trunc_time_o=6):
    """
    untangle the connections between starts and ends generated by delauney.
    use the group information, keep only connnect within each group.
    this still produce isolated points.

    Parameters
    -------
    g: the graph generated by delaunay
    groups: groups of each cell
    addedges: use which to extract all start celltypes and end celltyps.
    layouts: circled layouts, reconstruct delaunay on each start and end cluster
    olayouts: use to remove too far edges in the original layouts
    all_nodes_in_celltype: if run delaunay on all start cluster cells or only cells from the addedges
    trunc_quantile_cluster: truncate delaunay for start and end clusters
    trunc_times_cluster: truncate delaunay for start and end clusters
    trunc_quantile_o: truncate for original layouts
    trunc_time_o: truncate for original layouts

    Return
    -----
    G_dis: disconnected Delaunay Graph for trajectories
    G_con: connected Delaunay graph for L1 holes
    """

    ## might be networkx.Graph layouts dict, convert to list
    if type(layouts) == dict:
        layouts = np.array([layouts[x] for x in range(max(layouts.keys()) + 1)])

    if type(olayouts) == dict:
        olayouts = np.array([olayouts[x] for x in range(max(olayouts.keys()) + 1)])

    G_dis = copy.deepcopy(g)
    G_con = copy.deepcopy(g)

    for i in [x for (x, y) in addedges]:
        for j in [y for (x, y) in addedges]:
            if G_dis.has_edge(i, j):
                G_dis.remove_edge(i,j)
            if G_dis.has_edge(j, i):
                G_dis.remove_edge(j, i)

    starts = [x for (x, y) in addedges]
    ends = [y for (x, y) in addedges]

    start_cts = list(set(group[starts]))
    end_cts = list(set(group[ends]))
    start_nodes = starts
    end_nodes_arr = np.array([ends])
    if all_nodes_in_celltype:
        start_nodes = np.ravel([np.where(group == start_ct)[0] for start_ct in start_cts])
        end_nodes_arr = [np.where(group == end_ct)[0] for end_ct in end_cts]
    else:
        end_nodes_arr = []
        for i in range(len(end_cts)):
            end_nodes_arr.append([i for i in np.where(group == end_cts[i])[0] if i in set(ends)])

    start_edges = [(start_nodes[x], start_nodes[y])
                            for (x,y) in truncated_delaunay(layouts[list(start_nodes)],
                                                            trunc_quantile=trunc_quantile_cluster,
                                                            trunc_times=trunc_times_cluster)]
    end_edges = [(end_nodes_arr[i][x],end_nodes_arr[i][y])
                            for i in range(len(end_nodes_arr))
                            for (x,y) in truncated_delaunay(layouts[list(end_nodes_arr[i])],
                                                            trunc_quantile=trunc_quantile_cluster,
                                                            trunc_times=trunc_times_cluster,
                                                            )]


    ## add delaunay of start cluster
    for (x,y) in start_edges:
        e = tuple_increase(x,y)
        G_dis.add_edge(e[0], e[1])
        G_con.add_edge(e[0], e[1])

    ## add delaunay of end clusters
    for (x,y) in end_edges:
        e = tuple_increase(x,y)
        G_dis.add_edge(e[0], e[1])
        G_con.add_edge(e[0], e[1])



    ## remove too long edges from original laytouts
    dis_edges_distance = [distance.euclidean(tuple(olayouts[a]),tuple(olayouts[b])) for (a,b) in G_dis.edges()]
    threshold = np.quantile(dis_edges_distance, trunc_quantile_o) * trunc_time_o
    G_dis_edges = list(G_dis.edges())
    set_keep_edges = set([G_dis_edges[i] for i in range(len(G_dis_edges)) if dis_edges_distance[i] < threshold])
    set_dis_edges = set(G_dis_edges)

    set_rm_edges = set_dis_edges - set_keep_edges

    for (x,y) in set_rm_edges:
        G_dis.remove_edge(x,y)


    return G_dis, G_con
#endf untangle_starts_ends




def untangle_starts_ends_with_orignal(g,
                                      og,
                                      addedges,
                                      layouts,
                                      olayouts,
                                      all_nodes_in_celltype=False,
                                      trunc_quantile=1,
                                      trunc_times=1,
                                      trunc_quantile_o=0.75,
                                      trunc_time_o=6):
    """
    untangle the connections between starts and ends generated by delauney.
    use the group information, keep only connnect within each group.
    this still produce isolated points.

    Parameters
    -------
    g: the graph generated by delaunay
    groups: groups of each cell
    addedges: use which to extract all start celltypes and end celltyps.
    layouts: circled layouts, reconstruct delaunay on each start and end cluster
    olayouts: use to remove too far edges in the original layouts
    all_nodes_in_celltype: if run delaunay on all start cluster cells or only cells from the addedges
    trunc_quantile_cluster: truncate delaunay for start and end clusters
    trunc_times_cluster: truncate delaunay for start and end clusters
    trunc_quantile_o: truncate for original layouts
    trunc_time_o: truncate for original layouts

    Return
    -----
    G_dis: disconnected Delaunay Graph for trajectories
    G_con: connected Delaunay graph for L1 holes
    """

    ## might be networkx.Graph layouts dict, convert to list
    if type(layouts) == dict:
        layouts = np.array([layouts[x] for x in range(max(layouts.keys()) + 1)])

    if type(olayouts) == dict:
        olayouts = np.array([olayouts[x] for x in range(max(olayouts.keys()) + 1)])

    G_dis = copy.deepcopy(g)
    G_con = copy.deepcopy(g)

    for i in [x for (x, y) in addedges]:
        for j in [y for (x, y) in addedges]:
            if G_dis.has_edge(i, j):
                G_dis.remove_edge(i,j)
            if G_dis.has_edge(j, i):
                G_dis.remove_edge(j, i)

    con_nodes = list(set([i for x in addedges for i in x]))
    o_edges = og.edges(con_nodes)


    ### add edges from original circle node
    for (x,y) in o_edges:
        e = tuple_increase(x,y)
        G_dis.add_edge(e[0], e[1])
        G_con.add_edge(e[0], e[1])

    ## remove too long edges from original laytouts
    dis_edges_distance = [distance.euclidean(tuple(olayouts[a]),tuple(olayouts[b])) for (a,b) in G_dis.edges()]
    threshold = np.quantile(dis_edges_distance, trunc_quantile_o) * trunc_time_o
    G_dis_edges = list(G_dis.edges())
    set_keep_edges = set([G_dis_edges[i] for i in range(len(G_dis_edges)) if dis_edges_distance[i] < threshold])
    set_dis_edges = set(G_dis_edges)

    set_rm_edges = set_dis_edges - set_keep_edges

    for (x,y) in set_rm_edges:
        G_dis.remove_edge(x,y)


    ## remove too long edges from new laytouts
    dis_edges_distance = [distance.euclidean(tuple(layouts[a]),tuple(layouts[b])) for (a,b) in G_dis.edges()]
    threshold = np.quantile(dis_edges_distance, trunc_quantile) * trunc_times
    G_dis_edges = list(G_dis.edges())
    set_keep_edges = set([G_dis_edges[i] for i in range(len(G_dis_edges)) if dis_edges_distance[i] < threshold])
    set_dis_edges = set(G_dis_edges)

    set_rm_edges = set_dis_edges - set_keep_edges

    for (x,y) in set_rm_edges:
        G_con.remove_edge(x,y)
        G_dis.remove_edge(x,y)




    return G_dis, G_con




def connect_starts_ends_with_orignal(g,
                                     og,
                                     addedges,
                                     layouts,
                                     olayouts,
                                     all_nodes_in_celltype=False,
                                     trunc_quantile=1,
                                     trunc_times=1,
                                     trunc_quantile_o=0.75,
                                     trunc_time_o=6):
    """
    untangle the connections between starts and ends generated by delauney.
    use the group information, keep only connnect within each group.
    this still produce isolated points.

    Parameters
    -------
    g: the graph generated by delaunay
    groups: groups of each cell
    addedges: use which to extract all start celltypes and end celltyps.
    layouts: circled layouts, reconstruct delaunay on each start and end cluster
    olayouts: use to remove too far edges in the original layouts
    all_nodes_in_celltype: if run delaunay on all start cluster cells or only cells from the addedges
    trunc_quantile_cluster: truncate delaunay for start and end clusters
    trunc_times_cluster: truncate delaunay for start and end clusters
    trunc_quantile_o: truncate for original layouts
    trunc_time_o: truncate for original layouts

    Return
    -----
    G_dis: disconnected Delaunay Graph for trajectories
    G_con: connected Delaunay graph for L1 holes
    """

    ## might be networkx.Graph layouts dict, convert to list
    if type(layouts) == dict:
        layouts = np.array([layouts[x] for x in range(max(layouts.keys()) + 1)])

    if type(olayouts) == dict:
        olayouts = np.array([olayouts[x] for x in range(max(olayouts.keys()) + 1)])

    G_dis = copy.deepcopy(g)
    G_con = copy.deepcopy(g)

    for i in [x for (x, y) in addedges]:
        for j in [y for (x, y) in addedges]:
            if G_dis.has_edge(i, j):
                G_dis.remove_edge(i,j)
            if G_dis.has_edge(j, i):
                G_dis.remove_edge(j, i)

    con_nodes = list(set([i for x in addedges for i in x]))
    o_edges = og.edges(con_nodes)


    ### add edges from original circle node
    for (x,y) in o_edges:
        e = tuple_increase(x,y)
        G_dis.add_edge(e[0], e[1])
        G_con.add_edge(e[0], e[1])

    ## remove too long edges from original laytouts
    dis_edges_distance = [distance.euclidean(tuple(olayouts[a]),tuple(olayouts[b])) for (a,b) in G_dis.edges()]
    threshold = np.quantile(dis_edges_distance, trunc_quantile_o) * trunc_time_o
    G_dis_edges = list(G_dis.edges())
    set_keep_edges = set([G_dis_edges[i] for i in range(len(G_dis_edges)) if dis_edges_distance[i] < threshold])
    set_dis_edges = set(G_dis_edges)

    set_rm_edges = set_dis_edges - set_keep_edges

    for (x,y) in set_rm_edges:
        G_dis.remove_edge(x,y)


    ## remove too long edges from new laytouts
    dis_edges_distance = [distance.euclidean(tuple(layouts[a]),tuple(layouts[b])) for (a,b) in G_dis.edges()]
    threshold = np.quantile(dis_edges_distance, trunc_quantile) * trunc_times
    G_dis_edges = list(G_dis.edges())
    set_keep_edges = set([G_dis_edges[i] for i in range(len(G_dis_edges)) if dis_edges_distance[i] < threshold])
    set_dis_edges = set(G_dis_edges)

    set_rm_edges = set_dis_edges - set_keep_edges

    for (x,y) in set_rm_edges:
        G_con.remove_edge(x,y)
        G_dis.remove_edge(x,y)




    return G_dis, G_con


def connect_starts_ends_with_Delaunay_(g,
                                      layouts,
                                      group,
                                      quant=0.1,
                                      node_attr='u',
                                      start_n=5,
                                      end_n = 5,
                                      separate_ends_triangle = False,
                                      random_seed = 2022
                                      ):
    """
    untangle the connections between starts and ends generated by delauney.
    use the group information, keep only connnect within each group.
    this still produce isolated points.

    Parameters
    -------
    g: the graph generated by delaunay
    group: groups of each cell
    addedges: use which to extract all start celltypes and end celltyps.
    layouts: Delaunay layouts, for reconstructing delaunay on each start and end cluster
    start_n:
    end_n:
    separate_ends_triangle:
    random_seed:

    Return
    -----
    G_con: connected Delaunay graph for L1 holes
    """
    random.seed(random_seed)

    #import pdb
    #pdb.set_trace()


    values = np.fromiter(nx.get_node_attributes(g, node_attr).values(), dtype=np.float)

    n=len(g.nodes())
    o=np.sort(values)
    early=np.where(values<=o[round(n*quant)])[0]
    later=np.where(values>=o[round(n*(1-quant))])[0]

    #node_attr='u'
    #start_n = 10
    #end_n = 10


    if start_n <=0 or end_n <=0:
        raise ValueError("start_n and end_n must be positive")
    ## might be networkx.Graph layouts dict, convert to list
    if type(layouts) == dict:
        layouts = np.array([layouts[x] for x in range(max(layouts.keys()) + 1)])

    G_ae = copy.deepcopy(g)
    starts = early
    ends = later
    u = nx.get_node_attributes(g, node_attr)

    start_cts = list(set(group[starts]))
    end_cts = list(set(group[ends]))
    start_nodes = np.concatenate([np.where(group == start_ct)[0] for start_ct in start_cts]).ravel()
    n_start_nodes = top_n_from(start_nodes, u, min(start_n, len(start_nodes)), largest=False)

    end_nodes_arr = []
    for i in range(len(end_cts)):
        end_nodes_arr.append([i for i in np.where(group == end_cts[i])[0] if i in set(ends)])

    end_nodes_sets = [set(x) for x in end_nodes_arr]
    #print(end_nodes_arr)
    #print(end_n)
    n_end_nodes_arr = [top_n_from(arr, u, min(end_n, len(arr)), largest=True) for arr in end_nodes_arr]
    n_end_nodes= [y for x in end_nodes_arr for y in x]

    #for n_end_nodes in end_nodes_arr:
    #    G_ae.add_edges_from(zip(n_start_nodes, random.choices(list(n_end_nodes), k=end_n)))
    #    G_ae.add_edges_from(zip(n_end_nodes, random.choices(list(n_start_nodes), k=start_n)))
    ti = tuple_increase
    if separate_ends_triangle: ## each ends create triangles with the starts
        for i in range(len(n_end_nodes_arr)):
            selected_nodes = list(n_start_nodes) + list(n_end_nodes_arr[i])
            tri = Delaunay(np.array(layouts)[selected_nodes])
            tri_edges =[[ti(a,b),ti(a,c),ti(b,c)] for a,b,c in tri.simplices]
            tri_edges = list(set([item for sublist in tri_edges for item in sublist])) # flatten
            tri_edges = [(selected_nodes[x], selected_nodes[y]) for (x,y) in tri_edges]
            #print(len(tri_edges))
            G_ae.add_edges_from(tri_edges)
    else:
        selected_nodes = list(n_start_nodes) + list(n_end_nodes)
        tri = Delaunay(np.array(layouts)[selected_nodes])
        tri_edges =[[ti(a,b),ti(a,c),ti(b,c)] for a,b,c in tri.simplices]
        tri_edges = list(set([item for sublist in tri_edges for item in sublist])) # flatten
        tri_edges = [(selected_nodes[x], selected_nodes[y]) for (x,y) in tri_edges]
        print(len(tri_edges))
        tri_edges = [(x,y) for (x,y) in tri_edges if not is_in_2sets(x,y, end_nodes_sets)]
        print(len(tri_edges))
        ## filtering, ends should not be together.
        G_ae.add_edges_from(tri_edges)

    return G_ae
#endf connect_starts_ends_with_Delaunay




def connect_starts_ends_with_Delaunay(g,
                                      layouts,
                                      addedges, ##Here don't need to run the function, but just select the top and the end.
                                      group,
                                      node_attr='u',
                                      start_n=5,
                                      end_n = 5,
                                      separate_ends_triangle = False,
                                      random_seed = 2022
                                      ):
    """
    untangle the connections between starts and ends generated by delauney.
    use the group information, keep only connnect within each group.
    this still produce isolated points.

    Parameters
    -------
    g: the graph generated by delaunay
    group: groups of each cell
    addedges: use which to extract all start celltypes and end celltyps.
    layouts: Delaunay layouts, for reconstructing delaunay on each start and end cluster
    start_n:
    end_n:
    separate_ends_triangle:
    random_seed:

    Return
    -----
    G_con: connected Delaunay graph for L1 holes
    """


    #node_attr='u'
    #start_n = 10
    #end_n = 10

    random.seed(random_seed)

    if start_n <=0 or end_n <=0:
        raise ValueError("start_n and end_n must be positive")
    ## might be networkx.Graph layouts dict, convert to list
    if type(layouts) == dict:
        layouts = np.array([layouts[x] for x in range(max(layouts.keys()) + 1)])

    G_ae = copy.deepcopy(g)
    #import pdb
    #pdb.set_trace()

    starts = [x for (x, y) in addedges]
    ends = [y for (x, y) in addedges]
    u = nx.get_node_attributes(g, node_attr)

    start_cts = list(set(group[starts]))
    end_cts = list(set(group[ends]))
    start_nodes = np.concatenate([np.where(group == start_ct)[0] for start_ct in start_cts]).ravel()
    n_start_nodes = top_n_from(start_nodes, u, min(start_n, len(start_nodes)), largest=False)

    end_nodes_arr = []
    for i in range(len(end_cts)):
        end_nodes_arr.append([i for i in np.where(group == end_cts[i])[0] if i in set(ends)])

    end_nodes_sets = [set(x) for x in end_nodes_arr]
    #print(end_nodes_arr)
    #print(end_n)
    n_end_nodes_arr = [top_n_from(arr, u, min(end_n, len(arr)), largest=True) for arr in end_nodes_arr]
    n_end_nodes= [y for x in end_nodes_arr for y in x]

    #for n_end_nodes in end_nodes_arr:
    #    G_ae.add_edges_from(zip(n_start_nodes, random.choices(list(n_end_nodes), k=end_n)))
    #    G_ae.add_edges_from(zip(n_end_nodes, random.choices(list(n_start_nodes), k=start_n)))
    ti = tuple_increase
    if separate_ends_triangle: ## each ends create triangles with the starts
        for i in range(len(n_end_nodes_arr)):
            selected_nodes = list(n_start_nodes) + list(n_end_nodes_arr[i])
            tri = Delaunay(np.array(layouts)[selected_nodes])
            tri_edges =[[ti(a,b),ti(a,c),ti(b,c)] for a,b,c in tri.simplices]
            tri_edges = list(set([item for sublist in tri_edges for item in sublist])) # flatten
            tri_edges = [(selected_nodes[x], selected_nodes[y]) for (x,y) in tri_edges]
            #print(len(tri_edges))
            G_ae.add_edges_from(tri_edges)
    else:
        selected_nodes = list(n_start_nodes) + list(n_end_nodes)
        tri = Delaunay(np.array(layouts)[selected_nodes])
        tri_edges =[[ti(a,b),ti(a,c),ti(b,c)] for a,b,c in tri.simplices]
        tri_edges = list(set([item for sublist in tri_edges for item in sublist])) # flatten
        tri_edges = [(selected_nodes[x], selected_nodes[y]) for (x,y) in tri_edges]
        print(len(tri_edges))
        tri_edges = [(x,y) for (x,y) in tri_edges if not is_in_2sets(x,y, end_nodes_sets)]
        print(len(tri_edges))
        ## filtering, ends should not be together.
        G_ae.add_edges_from(tri_edges)

    return G_ae
#endf connect_starts_ends_with_Delaunay


def reset_edges(g:nx.Graph, edges, keep_old=False) -> nx.Graph:
    """
    Replace all edges with new edges

    Parameters
    ----------
    g: graph
    edges: new edges to replace edges of g
    keep_old: if keep old edges of the graph
    """
    #ti=tuple_increase
    #edges = [ti(x[0], x[1]) for x in edges]
    ti = tuple_increase

    ng = nx.create_empty_copy(g)
    ng = nx.Graph(nx.to_undirected(ng))
    if keep_old:
        diffusion_knn_edge = [ti(x[0], x[1]) for x in g.edges()]
        merged_edges = diffusion_knn_edge+ edges
        merged_edges = list(set(merged_edges))
        ng.add_edges_from(merged_edges)
    else:
        ng.add_edges_from(edges)
    return ng


